GRUB(Boot Loader)：

	grub: GRand Unified Bootloader
		grub 0.x: grub legacy
		grub 1.x: grub2

	grub legacy:
		stage1: mbr
		stage1_5: mbr之后的扇区，让stage1中的bootloader能识别stage2所在的分区上的文件系统；
		stage2：磁盘分区(/boot/grub/)

		配置文件：/boot/grub/grub.conf <-- /etc/grub.conf

		stage2及内核等通常放置于一个基本磁盘分区；
			功用：
				(1) 提供菜单、并提供交互式接口
					e: 编辑模式，用于编辑菜单；
					c: 命令模式，交互式接口；
				(2) 加载用户选择的内核或操作系统
					允许传递参数给内核
					可隐藏此菜单
				(3) 为菜单提供了保护机制
					为编辑菜单进行认证
					为启用内核或操作系统进行认证

		如何识别设备：
			(hd#,#)
				hd#: 磁盘编号，用数字表示；从0开始编号
				#: 分区编号，用数字表示; 从0开始编号

				(hd0,0)

		grub的命令行接口
			help: 获取帮助列表
			help KEYWORD: 详细帮助信息
			find (hd#,#)/PATH/TO/SOMEFILE：
			root (hd#,#)
			kernel /PATH/TO/KERNEL_FILE: 设定本次启动时用到的内核文件；额外还可以添加许多内核支持使用的cmdline参数；
				例如：init=/path/to/init, selinux=0
			initrd /PATH/TO/INITRAMFS_FILE: 设定为选定的内核提供额外文件的ramdisk；
			boot: 引导启动选定的内核；

			手动在grub命令行接口启动系统：
				grub> root (hd#,#)
				grub> kernel /vmlinuz-VERSION-RELEASE ro root=/dev/DEVICE 
				grub> initrd /initramfs-VERSION-RELEASE.img
				grub> boot

		配置文件：/boot/grub/grub.conf
			配置项：
				default=#: 设定默认启动的菜单项；落单项(title)编号从0开始；
				timeout=#：指定菜单项等待选项选择的时长；
				splashimage=(hd#,#)/PATH/TO/XPM_PIC_FILE：指明菜单背景图片文件路径；
				hiddenmenu：隐藏菜单；
				password [--md5] STRING: 菜单编辑认证；
				title TITLE：定义菜单项“标题”, 可出现多次；
					root (hd#,#)：grub查找stage2及kernel文件所在设备分区；为grub的“根”; 
					kernel /PATH/TO/VMLINUZ_FILE [PARAMETERS]：启动的内核
					initrd /PATH/TO/INITRAMFS_FILE: 内核匹配的ramfs文件；
					password [--md5] STRING: 启动选定的内核或操作系统时进行认证；


			grub-md5-crypt命令

		进入单用户模式：
			(1) 编辑grub菜单(选定要编辑的title，而后使用e命令); 
			(2) 在选定的kernel后附加
				1, s, S或single都可以；
			(3) 在kernel所在行，键入“b”命令；

		安装grub：
			(1) grub-install
				grub-install --root-directory=ROOT /dev/DISK
			
			(2) grub
				grub> root (hd#,#)
				grub> setup (hd#)

		练习：
			1、新加硬盘，提供直接单独运行bash系统；
			2、破坏本机grub stage1，而后在救援模式下修复之；
			3、为grub设置保护功能；

	博客作业：grub应用；






编译内核：
	
	程序包的编译安装：
		./configure, make, make install
		
	前提：开发环境（开发工具，开发库），头文件：/usr/include 
	
	开源：源代码 --> 可执行格式
		发行版：以“通用”的目标；
		
	前提：
		(1) 准备好开发环境；
		(2) 获取目标主机上硬件设备的相关信息；
		(3) 获取到目标主机系统功能的相关信息，例如要启用的文件系统； 
		(4) 获取内核源代码包：www.kernel.org
		
		准备开发环境：
			CentOS 6.7：
				包组：
					Development Tools
					Server Platform Development 
					
			CentOS 7：
				包组：
					Development Tools
					Server Platform Development 
					
				包：
					ncurses-devel
					
		获取目标主机上硬件设备的相关信息：
			CPU：
				~]# cat  /proc/info
				~]# lscpu
				~]# x86info -a
				
			PCI设备：
				~]# lspci
					-v
					-vv
					
				~]# lsusb
					-v
					-vv
					
				~]# lsblk
				
			了解全部硬件设备信息：
				~]# hal-device
				
		内核编译过程：
			步骤：
				~]# tar  xf  linux-3.10.67.tar.xz  -C  /usr/src
				~]# cd  /usr/src
				~]# ln  -s  linux-3.10.67  linux
				~]# cd  linux
				
				~]# make menuconfig       	配置内核选项
				~]# make  [-j #]			编译内核，可使用-j指定编译线程数量
				~]# make modules_install	安装内核模块
				~]# make install			安装内核 
				
				重启系统，选择使用新内核；
				
			screen命令：
				打开screen： ~]# screen
				拆除screen： Ctrl+a, d
				列出screen： ~]# screen  -ls
				连接至screen： ~]# screen  -r   SCREEN_ID
				关闭screen:  ～]# exit
		
		过程的详细说明：
			(1)  配置内核选项
				支持“更新”模式进行配置：在已有的.config文件的基础之上进行“修改”配置；
					(a) make config：基于命令行以遍历的方式去配置内核中可配置的每个选项；
					(b) make  menuconfig：基于cureses的文本配置窗口；
					(c) make  gconfig：基于GTK开发环境的窗口界面；  包组“桌面平台开发”
					(d) make  xonfig：基于QT开发环境的窗口界面；
				支持“全新配置”模式进行配置：
					(a) make  defconfig：基于内核为目标平台提供的“默认”配置为模板进行配置；
					(b) make   allnoconfig：所有选项均为“no”；
					
			(2) 编译
				 
				 (a) 多线程编译：make  [-j #]
				 (b) 编译内核中的一部分代码：
					(i) 只编译某子目录中的相关代码：
						# cd  /usr/src/linux
						# make  path/to/dir/
						
					(ii)只编译一个特定的模块
						# cd  /usr/src/linux
						# make  path/to/dir/file.ko
				(c) 如何交叉编译：
					目标平台与当前编译操作所在的平台不同；
					
					# make  ARCH=arch_name
					
					要获取特定目标平台的使用帮助：					
						# make  ARCH=arch_name help
						
			(3) 如何在执行过编译操作的内核源码树上做重新编译：
				事先清理操作：
					# make clean：清理编译生成的绝大多数文件，但会保留config，及编译外部模块所需要的文件；
					# make mrproper：清理编译生成的所有文件，包括配置生成的config文件及某些备份文件；
					# make distclean：相当于mrproper，额外清理各种patches以及编辑器备份文件；




CentOS 系统安装：
	
	安装程序：anaconda
	
		bootloader --> kernel(initrd(rootfs)) --> anaconda
		
		anaconda：
			tui：基于cureses的文本配置窗口
			gui：图形界面
			
		CentOS的安装过程启动流程：
			MBR：boot.cat
			Stage2：isolinux/isolinux.bin
				配置文件：isolinux/isolinux.cfg
				
				每个对应的菜单选项：
					加载内核：isolinux/vmlinuz
					向内核传递参数：append  initrd=initrd.img
					
				装载根文件系统，并启动anaconda
				
					默认界面是图形界面：512MB+内存空间；
					若需要显式指定启动TUI接口： 向启动内核传递一个参数"text"即可；
					
						ESC,
							boot: linux  text
		
				 
				 注意：上述内容一般位于引导设备，例如可通过光盘、U盘或网络等；后续的anacona及其安装用到的程序包等可以来自于程序包仓库，此仓库的位置可以为：
					本地光盘
					本地硬盘
					ftp server
					http server
					nfs server
					
					如果想手动指定安装仓库：
						ESC
							boot: linux method
							
		anaconda的工作过程：
			安装前配置阶段
				安装过程使用的语言；
				键盘类型
				安装目标存储设备
					Basic Storage：本地磁盘
					Special Storage： iSCSI
				设定主机名
				配置网络接口
				时区
				管理员密码
				设定分区方式及MBR的安装位置；
				创建一个普通用户；
				选定要安装的程序包；
			安装阶段
				在目标磁盘创建分区并执行格式化；
				将选定的程序包安装至目标位置；
				安装bootloader；
			首次启动
				iptables
				selinux
				core dump 
				
		anaconda的配置方式：
			(1) 交互式配置方式； 
			(2) 支持通过读取配置文件中事先定义好的配置项自动完成配置；遵循特定的语法格式，此文件即为kickstart文件；
			
		安装引导选项：
			boot:
				text：文本安装方式
				method：手动指定使用的安装方法
				与网络相关的引导选项：
					ip=IPADDR
					netmask=MASK
					gateway=GW
					dns=DNS_SERVER_IP
				远程访问功能相关的引导选项：
					vnc
					vncpassword='PASSWORD'
				启动紧急救援模式：
					rescue
				装载额外驱动：
					dd
					
				www.redhat.com/docs , 《installation guide》






CentOS系统安装：
	
	CentOS 6.7 x86_64: 
		minimal install
		
	安装引导选项：
		ks：指明kickstart文件的位置；
			ks=
				DVD drive: ks=cdrom:/PATH/TO/KICKSTART_FILE
				Hard Drive： ks=hd:/DEVICE/PATH/TO/KICKSTART_FILE
				HTTP Server： ks=http://HOST[:PORT]/PATH/TO/KICKSTART_FILE
				FTP Server:  ks=ftp://HOST[:PORT]/PATH/TO/KICKSTART_FILE
				HTTPS Server:   ks=https://HOST[:PORT]/PATH/TO/KICKSTART_FILE
		
	kickstart文件的格式
		命令段：
			指定各种安装前配置选项，如键盘类型等；
				必备命令
				可选命令
		程序包段：
			指明要安装程序包，以及包组，也包括不安装的程序包；
				%packages
				@group_name
				package
				-package
				%end
		脚本段：
			%pre：安装前脚本
				运行环境：运行安装介质上的微型Linux系统环境；
			
			%post：安装后脚本
				运行环境：安装完成的系统；
				
				
		命令段中的必备命令：
			authconfig：认证方式配置
				authconfig  --enableshadow  --passalgo=sha512
			bootloader：定义bootloader的安装位置及相关配置
				bootloader  --location=mbr  --driveorder=sda  --append="crashkernel=auto rhgb quiet"
			keyboard：设置键盘类型
				keyboard us
			lang：语言类型
				lang  zh_CN.UTF-8
			part：分区布局；
				part  /boot  --fstype=ext4  --size=500
				part  pv.008002  --size=51200
			rootpw：管理员密码
				rootpw   --iscrypted  $6$4Yh15kMGDWOPtbbW$SGax4DsZwDAz4201.O97WvaqVJfHcISsSQEokZH054juNnoBmO/rmmA7H8ZsD08.fM.Z3Br/67Uffod1ZbE0s.
			timezone：时区
				timezone  Asia/Shanghai
				
			补充：分区相关的其它指令
				clearpart：清除分区
					clearpart  --none  --drives=sda：清空磁盘分区；
				volgroup：创建卷组
					volgroup  myvg  --pesize=4096  pv.008002
				logvol：创建逻辑卷
					logvol  /home  --fstype=ext4  --name=lv_home  --vgname=myvg  --size=5120
					
				生成加密密码的方式：
					~]# openssl  passwd  -1  -salt `openssl rand -hex 4`
		
		可选命令：
			install  OR  upgrade：安装或升级；
			text：安装界面类型，text为tui，默认为GUI
			network：配置网络接口
				network  --onboot yes  --device eth0  --bootproto dhcp  --noipv6
			firewall：防火墙 
				firewall  --disabled
			selinux：SELinux
				selinux --disabled
			halt、poweroff或reboot：安装完成之后的行为；
			repo：指明安装时使用的repository；
				repo  --name="CentOS"   --baseurl=cdrom:sr0  --cost=100
			url： 指明安装时使用的repository，但为url格式；
				url --url=http://172.16.0.1/cobbler/ks_mirror/CentOS-6.7-x86_64/	
				
		参考官方文档：《Installation Guide》
					
			系统安装完成之后禁用防火墙：
				CentOS 6：
					# service iptables  stop
					# chkconfig  iptables  off 
				CentOS 7：
					# systemctl  stop  firewalld.service 
					# systemctl  disable  firewalld.service
					
			系统安装完成后禁用SELinux：
				编辑/etc/sysconfig/selinux或/etc/selinux/config文件，修改SELINUX参数的值为下面其中之一：
					permissive
					disabled
					
				立即生效：
					# getenforce
					# setenforce  0
			
		定制kickstart文件：
			# yum install  system-config-kickstart
			# system-config-kickstart
			
			检查语法错误：
			# ksvalidator
	
	创建光盘镜像：
		~]# mkisofs -R -J -T -v --no-emul-boot --boot-load-size 4 --boot-info-table -V "CentOS 6 x86_64 boot" -c isolinux/boot.cat -b isolinux/isolinux.bin -o  /root/boot.iso   myboot/





bash脚本编程：
	顺序执行
	选择分支
	循环执行
		for, while, until
		
		进入条件：
			for：列表元素非空；
			while：条件测试结果为“真”
			unitl：条件测试结果为“假”
		退出条件：
			for：列表元素遍历完成；
			while：条件测试结果为“假”
			until：条件测试结果为“真”
			
		循环控制语句：
			continue：提前结束本轮循环，而直接进入下一轮循环判断；
				while  CONDITION1; do
					CMD1
					...
					if  CONDITION2; then
						continue
					fi
					CMDn
					...
				done
				
				示例：求100以内所有偶数之和；										
					#!/bin/bash
					#
					declare -i evensum=0
					declare -i i=0

					while [ $i -le 100 ]; do
						let i++
						if [ $[$i%2] -eq 1 ]; then
							continue
						fi
						let evensum+=$i
					done

					echo "Even sum: $evensum"				
			
			break：提前跳出循环
				while  CONDITION1; do
					CMD1
					...
					if  CONDITION2; then
						break
					fi
				done
				
		创建死循环：
			while true; do
				循环体
			done
			
			退出方式：
				某个测试条件满足时，让循环体执行break命令；
				
			示例：求100以内所奇数之和
				#!/bin/bash
				#
				declare -i oddsum=0
				declare -i i=1

				while true; do
					let oddsum+=$i
					let i+=2
					if [ $i -gt 100 ]; then
						break
					fi
				done
				
			sleep命令：
				- delay for a specified amount of time
			
				sleep NUMBER
				
			练习：每隔3秒钟到系统上获取已经登录用户的用户的信息；其中，如果logstash用户登录了系统，则记录于日志中，并退出；
				#!/bin/bash
				#
				while true; do
					if who | grep "^logstash\>" &> /dev/null; then
						break
					fi
					sleep 3
				done

				echo "$(date +"%F %T") logstash logged on" >> /tmp/users.log	
				
				#!/bin/bash
				#
				until who | grep "^logstash\>" &> /dev/null; do
					sleep 3
				done

				echo "$(date +"%F %T") logstash logged on" >> /tmp/users.log			
			
		while循环的特殊用法（遍历文件的行）：
			
			while  read  VARIABLE; do
				循环体；
			done  <  /PATH/FROM/SOMEFILE
			
			依次读取/PATH/FROM/SOMEFILE文件中的每一行，且将基赋值给VARIABLE变量；
			
			示例：找出ID号为偶数的用户，显示其用户名、ID及默认shell；
				#!/bin/bash
				#
				while read line; do
					userid=$(echo $line | cut -d: -f3)
					username=$(echo $line | cut -d: -f1)
					usershell=$(echo $line | cut -d: -f7)

					if [ $[$userid%2] -eq 0 ]; then
						echo "$username, $userid, $usershell."
					fi
				done < /etc/passwd				
							
		for循环的特殊用法：
			for  ((控制变量初始化;条件判断表达式;控制变量的修正语句)); do
				循环体
			done
			
			控制变量初始化：仅在循环代码开始运行时执行一次；
			控制变量的修正语句：每轮循环结束会先进行控制变量修正运算，而后再做条件判断；
			
			示例：求100以内所有正整数之和
				#!/bin/bash
				#
				declare -i sum=0

				for ((i=1;i<=100;i++)); do
					let sum+=$i
				done

				echo "Sum: $sum."
				
			示例：打印九九乘法表
				#!/bin/bash
				#
				for ((j=1;j<=9;j++)); do
					for ((i=1;i<=j;i++)); do
						echo -e -n "${i}X${j}=$[${i}*${j}]\t"
					done
					echo
				done				


bash脚本编程：

	case语句：
		
		多分支if语句：
			if CONDITION1; then
				分支1
			elif  CONDITION2; then
				分支2
			...
			else CONDITION; then
				分支n
			fi
			
		示例1：显示一个菜单给用户；
			cpu) display cpu information
			mem) display memory information
			disk) display disks information
			quit) quit
			
			要求：(1) 提示用户给出自己的选择；
				   (2) 正确的选择则给出相应的信息；否则，则提示重新选择正确的选项；
				   
				#!/bin/bash
				#
				cat << EOF
				cpu) display cpu information
				mem) display memory infomation
				disk) display disks information
				quit) quit
				===============================
				EOF

				read -p "Enter your option: " option

				while [ "$option" != "cpu" -a "$option" != "mem" -a "$option" != "disk" -a "$option" != "quit" ]; do
					echo "cpu, mem, disk, quit"
					read -p "Enter your option again: " option
				done

				if [ "$option" == "cpu" ]; then
					lscpu
				elif [ "$option" == "mem" ]; then
					free -m
				elif [ "$option" == "disk" ]; then
					fdisk -l /dev/[hs]d[a-z]
				else
					echo "quit"
					exit 0
				fi		
	
			case语句的语法格式：
				
				case  $VARAIBLE  in  
				PAT1)
					分支1
					;;
				PAT2)
					分支2
					;;
				...
				*)
					分支n
					;;
				esac
				
				case支持glob风格的通配符：
					*：任意长度的任意字符；
					?：任意单个字符；
					[]：范围内任意单个字符；
					a|b：a或b；
				
			示例：写一个服务框架脚本；
				$lockfile,  值/var/lock/subsys/SCRIPT_NAME
				
				(1) 此脚本可接受start, stop, restart, status四个参数之一；
				(2) 如果参数非此四者，则提示使用帮助后退出；
				(3) start，则创建lockfile，并显示启动；stop，则删除lockfile，并显示停止；restart，则先删除此文件再创建此文件，而后显示重启完成；status，如果lockfile存在，则显示running，否则，则显示为stopped.
				
					#!/bin/bash
					#
					# chkconfig: - 50 50
					# description: test service script
					#
					prog=$(basename $0)
					lockfile=/var/lock/subsys/$prog

					case $1  in
					start)
						if [ -f $lockfile ]; then
							echo "$prog is running yet."
						else
							touch $lockfile
							[ $? -eq 0 ] && echo "start $prog finshed."
						fi
						;;
					stop)
						if [ -f $lockfile ]; then
							rm -f $lockfile
							[ $? -eq 0 ] && echo "stop $prog finished."
						else
							echo "$prog is not running."
						fi
						;;
					restart)
						if [ -f $lockfile ]; then
							rm -f $lockfile
							touch $lockfile
							echo "restart $prog finished."
						else
							touch -f $lockfile
							echo "start $prog finished."
						fi
						;;
					status)
						if [ -f $lockfile ]; then
							echo "$prog is running"
						else
							echo "$prog is stopped."
						fi
						;;
					*)
						echo "Usage: $prog {start|stop|restart|status}"
						exit 1
					esac
			
	函数：function 
		过程式编程：代码重用
			模块化编程
			结构化编程 
			
			把一段独立功能的代码当作一个整体，并为之一个名字；命名的代码段，此即为函数；
			
			注意：定义函数的代码段不会自动执行，在调用时执行；所谓调用函数，在代码中给定函数名即可；
				函数名出现的任何位置，在代码执行时，都会被自动替换为函数代码；
				
		语法一：
			function  f_name  {
				...函数体...
			}
			
		语法二：
			f_name()  {
				...函数体...
			}
			
		函数的生命周期：每次被调用时创建，返回时终止；
			其状态返回结果为函数体中运行的最后一条命令的状态结果；
			自定义状态返回值，需要使用：return
				return [0-255]
					0: 成功
					1-255: 失败
				
		示例：给定一个用户名，取得用户的id号和默认shell；
			#!/bin/bash
			#

			userinfo() {
				if id "$username" &> /dev/null; then
					grep "^$username\>" /etc/passwd | cut -d: -f3,7
				else
					echo "No such user."
				fi
			}

			username=$1
			userinfo

			username=$2
			userinfo			
			
		示例2：服务脚本框架
			#!/bin/bash
			#
			# chkconfig: - 50 50
			# description: test service script
			#
			prog=$(basename $0)
			lockfile=/var/lock/subsys/$prog

			start() {
				if [ -f $lockfile ]; then
					echo "$prog is running yet."
				else
					touch $lockfile
					[ $? -eq 0 ] && echo "start $prog finshed."
				fi
			}

			stop() {
				if [ -f $lockfile ]; then
					rm -f $lockfile
					[ $? -eq 0 ] && echo "stop $prog finished."
				else
					echo "$prog is not running."
				fi
			}
			status() {
				if [ -f $lockfile ]; then
					echo "$prog is running"
				else
					echo "$prog is stopped."
				fi
			}

			usage() {
				echo "Usage: $prog {start|stop|restart|status}"
			}

			case $1 in
			start)
				start ;;
			stop)
				stop ;;
			restart)
				stop
				start ;;
			status)
				status ;;
			*)
				usage
				exit 1 ;;
			esac
			
		函数返回值：
			函数的执行结果返回值：
				(1) 使用echo或printf命令进行输出；
				(2) 函数体中调用的命令的执行结果；
			函数的退出状态码：
				(1) 默认取决于函数体中执行的最后一条命令的退出状态码；
				(2) 自定义：return
				
		函数可以接受参数：
			传递参数给函数：
				在函数体中当中，可以使用$1，$2, ...引用传递给函数的参数；还可以函数中使用$*或$@引用所有参数，$#引用传递的参数的个数；
				在调用函数时，在函数名后面以空白符分隔给定参数列表即可，例如，testfunc  arg1 arg2 arg3 ...
				
			示例：添加10个用户，
				添加用户的功能使用函数实现，用户名做为参数传递给函数；
				
					#!/bin/bash
					#
					# 5: user exists

					addusers() {
						if id $1 &> /dev/null; then
							return 5
						else
							useradd $1
							retval=$?
							return $retval
						fi
					}

					for i in {1..10}; do
						addusers ${1}${i}
						retval=$?
						if [ $retval -eq 0 ]; then
							echo "Add user ${1}${i} finished."
						elif [ $retval -eq 5 ]; then
							echo "user ${1}${i} exists."
						else
							echo "Unkown Error."
						fi
					done
			
		练习：写一个脚本；
			使用函数实现ping一个主机来测试主机的在线状态；主机地址通过参数传递给函数；
			主程序：测试172.16.1.1-172.16.67.1范围内各主机的在线状态；
			
		练习：写一个脚本；
			打印NN乘法表；
			
		变量作用域：
			局部变量：作用域是函数的生命周期；在函数结束时被自动销毁；
				定义局部变量的方法：local VARIABLE=VALUE
			本地变量：作用域是运行脚本的shell进程的生命周期；因此，其作用范围为当前shell脚本程序文件；
			
			示例程序：
				#!/bin/bash
				#
				name=tom

				setname() {
					local name=jerry
					echo "Function: $name"
				}

				setname
				echo "Shell: $name"
		
		函数递归：
			函数直接或间接调用自身；
				
			10!=10*9!=10*9*8!=10*9*8*7!=...
				n
					n*(n-1)!=n*(n-1)*(n-2)!=

				#!/bin/bash
				#
				fact() {
					if [ $1 -eq 0 -o $1 -eq 1 ]; then
						echo 1
					else
						echo $[$1*$(fact $[$1-1])]
					fi
				}

				fact $1					
					
					
			1,1,2,3,5,8,13,21,...
									
				#!/bin/bash
				#
				fab() {
					if [ $1 -eq 1 ]; then
						echo -n "1 "
					elif [ $1 -eq 2 ]; then
						echo -n "1 "
					else
						echo -n "$[$(fab $[$1-1])+$(fab $[$1-2])] "
					fi
				}

				for i in $(seq 1 $1); do
					fab $i
				done
				echo				











bash脚本编程：
	
	函数、case语言
		case语句：
			case  $VARIABLE  in 
			PAT1)
				分支1
				;;
			PAT2)
				分支2
				;;
			*)
				分支n
				;;
			esac
			
			PATTERN: GLOB, |
		
		函数：结构化编程，代码重用；
			function f_name {
				函数体
			}
			
			f_name() {
				函数体 
			}
			
			函数定义
			函数调用：给定函数名；
			
			局部变量：local  VARIABLE
		
	数组：
		程序=指令+数据
			指令：
			数据：变量、文件
		
		变量：存储单个元素的内存空间；
		数组：存储多个元素的连续的内存空间；
			数组名：整个数组只有一个名字；
			数组索引：编号从0开始；
				数组	名[索引]， 
				${ARRAY_NAME[INDEX]}
				
			注意：bash-4及之后的版本，支持自定义索引格式，而不仅仅是0，1,2，...数字格式；
				此类数组称之为“关联数组”
				
		声明数组：
			declare  -a  NAME：声明索引数组；
			declare  -A  NAME：声明关联数组；
			
		数组中元素的赋值方式：
			(1) 一次只赋值一个元素；
				ARRAY_NAME[INDEX]=value
			(2) 一次赋值全部元素；
				ARRAY_NAME=("VAL1"  "VAL2"  "VAL3"  ...)
			(3) 只赋值特定元素；
				ARRAY_NAME=([0]="VAL1"  [3]="VAL4" ...)
				
				注意：bash支持稀疏格式的数组；
			(4) read  -a  ARRAY_NAME
			
		引用数组中的元素：${ARRAY_NAME[INDEX]}
			注意：引用时，只给数组名，表示引用下标为0的元素；
			
		数组的长度（数组中元素的个数）:
			${#ARRAY_NAME[*]}
			${#ARRAY_NAME[@]}
			
		示例：生成10个随机数，并找出其中的最大值和最小值；
			#!/bin/bash
			#
			declare -a  rand
			declare -i max=0

			for i in {0..9}; do
				rand[$i]=$RANDOM
				echo ${rand[$i]}
				[ ${rand[$i]} -gt $max ] && max=${rand[$i]}
			done 

			echo "MAX: $max"			
			
		练习：生成10个随机数，而后由小到大进行排序；
		
		练习：写一个脚本
			定义一个数组，数组中的元素是/var/log目录下所有以.log结尾的文件；统计其下标为偶数的文件中的行数之和；
			
				#!/bin/bash
				#
				declare -a files
				files=(/var/log/*.log)

				declare -i lines=0

				for i in $(seq 0 $[${#files[*]}-1]); do
					if [ $[$i%2] -eq 0 ]; then
						let lines+=$(wc -l ${files[$i]} | cut -d' ' -f1)
					fi
				done

				echo "Lines: $lines."
				
		引用数组中的所有元素：
			${ARRAY_NAME[*]}
			${ARRAY_NAME[@]}
			
			数组元素切片： ${ARRAY_NAME[@]:offset:number}
				offset：要路过的元素个数；
				number：要取出的元素个数；省略number时，表示取偏移量之后的所有元素；
				
		向非稀疏格式数组中追加元素：
			ARRAY_NAME[${#ARRAY_NAME[*]}]=
			
		删除数组中的某元素：
			unset  ARRAY[INDEX]
			
		关联数组：
			declare  -A  ARRAY_NAME
				ARRAY_NAME=([index_name1]="value1"  [index_name2]="value2" ...)
				
	bash的内置字符串处理工具：
		
		字符串切片：
			${var:offset:number}
				取字符串的子串；
				取字符趾的最右侧的几个字符：${var:  -length}
					注意：冒号后必须有一个空白字符；
					
		基于模式取子串：
			${var#*word}：其中word是指定的分隔符；功能：自左而右，查找var变量所存储的字符串中，第一次出现的word分隔符，删除字符串开头至此分隔符之间的所有字符；
			${var##*word}：其中word是指定的分隔符；功能：自左而右，查找var变量所存储的字符串中，最后一次出现的word分隔符，删除字符串开头至此分隔符之间的所有字符；
				
				mypath="/etc/init.d/functions"
				${mypath##*/}:   functions
				${mypath#*/}:  etc/init.d/functions
				
			${var%word*}：其中word是指定的分隔符；功能：自右而左，查找var变量所存储的字符串中，第一次出现的word分隔符，删除此分隔符至字符串尾部之间的所有字符；
			${var%%word*}：其中word是指定的分隔符；功能：自右而左，查找var变量所存储的字符串中，最后一次出现的word分隔符，删除此分隔符至字符串尾部之间的所有字符；
			
				mypath="/etc/init.d/functions"
				${mypath%/*}:  /etc/init.d
				
				url=http://www.magedu.com:80
					${url##*:}
					${url%%:*}
					
		查找替换：
			${var/PATTERN/SUBSTI}：查找var所表示的字符串中，第一次被PATTERN所匹配到的字符串，将其替换为SUBSTI所表示的字符串；
			${var//PATTERN/SUBSTI}：查找var所表示的字符串中，所有被PATTERN所匹配到的字符串，并将其全部替换为SUBSTI所表示的字符串；
			
			${var/#PATTERN/SUBSTI}：查找var所表示的字符串中，行首被PATTERN所匹配到的字符串，将其替换为SUBSTI所表示的字符串；
			${var/%PATTERN/SUBSTI}：查找var所表示的字符串中，行尾被PATTERN所匹配到的字符串，将其替换为SUBSTI所表示的字符串；
						
			注意：PATTERN中使用glob风格和通配符；
			
		查找删除：
			${var/PATTERN}：以PATTERN为模式查找var字符串中第一次的匹配，并删除之；
			${var//PATERN}
			${var/#PATTERN}
			${var/%PATTERN}
			
		字符大小写转换：
			${var^^}：把var中的所有小写字符转换为大写；
			${var,,}：把var中的所有大写字符转换为小写；
			
		变量赋值：
			${var:-VALUE}：如果var变量为空，或未设置，那么返回VALUE；否则，则返回var变量的值； 
			${var:=VALUE}：如果var变量为空，或未设置，那么返回VALUE，并将VALUE赋值给var变量；否则，则返回var变量的值； 
			${var:+VALUE}：如果var变量不空，则返回VALUE；
			${var:?ERROR_INFO}：如果var为空，或未设置，那么返回ERROR_INFO为错误提示；否则，返回var值； 
			
	练习：写一个脚本，完成如下功能
		(1) 提示用户输入一个可执行命令的名称；
		(2) 获取此命令所依赖到的所有库文件列表；
		(3) 复制命令至某目标目录（例如/mnt/sysroot，即把此目录当作根）下的对应的路径中
			bash,  /bin/bash  ==> /mnt/sysroot/bin/bash
			useradd, /usr/sbin/useradd  ==>  /mnt/sysroot/usr/sbin/useradd
		(4) 复制此命令依赖到的所有库文件至目标目录下的对应路径下；
			/lib64/ld-linux-x8664.so.2  ==>  /mnt/sysroot/lib64/ld-linux-x8664.so.2
			
		进一步：
			每次复制完成一个命令后，不要退出，而是提示用户继续输入要复制的其它命令，并重复完成如上所描述的功能；直到用户输入“quit”退出脚本；
			
	
	写一个脚本：
		ping命令去查看172.16.1.1-172.16.67.1范围内的所有主机是否在线；在线的显示为up, 不在线的显示down，分别统计在线主机，及不在线主机数；
		
		分别使用for, while和until循环实现。
		
			#!/bin/bash
			#
			declare -i uphosts=0
			declare -i downhosts=0

			for i in {1..17}; do
				if ping -W 1 -c 1 172.16.$i.1 &> /dev/null; then
					echo "172.16.$i.1 is up."
					let uphosts+=1
				else
					echo "172.16.$i.1 is down."
					let downhosts+=1
				fi
			done

			echo "Up hosts: $uphosts, Down hosts: $downhosts."		
						
					
			#!/bin/bash
			#
			declare -i uphosts=0
			declare -i downhosts=0
			declare -i i=1

			hostping() {
				if ping -W 1 -c 1 $1 &> /dev/null; then
					echo "$1 is up."
					return 0
				else
					echo "$1 is down."
					return 1
				fi
			}

			while [ $i -le 67 ]; do
				hostping 172.16.$i.1
				[ $? -eq 0 ] && let uphosts++ || let downhosts++
				let i++
			done

			echo "Up hosts: $uphosts, Down hosts: $downhosts."					
				
	写一个脚本，实现：
		能探测C类、B类或A类网络中的所有主机是否在线；
			
			#!/bin/bash
			#

			cping() {
				local i=1
				while [ $i -le 5 ]; do
					if ping -W 1 -c 1 $1.$i &> /dev/null; then
						echo "$1.$i is up"
					else
						echo "$1.$i is down."
					fi
					let i++
				done
			}

			bping() {
				local j=0
				while [ $j -le 5 ]; do
					cping $1.$j
					let j++
				done
			}

			aping() {
				local x=0
				while [ $x -le 255 ]; do
					bping $1.$x
					let x++
				done
			}
			
		提示用户输入一个IP地址或网络地址；获取其网络，并扫描其网段；
		
	信号捕捉：
		列出信号：
			trap  -l
			kill  -l
			man  7  signal
		
			trap  'COMMAND'  SIGNALS
			
			常可以进行捕捉的信号：
				HUP， INT 
			
			示例：
				#!/bin/bash
				#
				declare -a hosttmpfiles
				trap  'mytrap'  INT

				mytrap()  {
					echo "Quit"
					rm -f ${hosttmpfiles[@]}
					exit 1
				}


				for i in {1..50}; do
					tmpfile=$(mktemp /tmp/ping.XXXXXX)
					if ping -W 1 -c 1 172.16.$i.1 &> /dev/null; then
						echo "172.16.$i.1 is up" | tee $tmpfile
					else
						echo "172.16.$i.1 is down" | tee $tmpfile
					fi
					hosttmpfiles[${#hosttmpfiles[*]}]=$tmpfile
				done

				rm -f ${hosttmpfiles[@]}
				
	在bash中使用ACSII颜色
		\033[31m hello \033[0m
			##m：
				左侧#：
					3：前景色
					4：背景色
				右侧#：颜色种类
					1, 2, 3, 4, 5, 6, 7
			
			#m：
				加粗、闪烁等功能；
				
			多种控制符，可组合使用，彼此间用分号隔开；
			
	dialog命令可实现窗口化编程；
		各窗体控件使用方式；
		如何获取用户选择或键入的内容？
			默认，其输出信息被定向到了错误输出流；
		
	《高级bash编程指南》，《Linux命令行和shell脚本编程宝典》
